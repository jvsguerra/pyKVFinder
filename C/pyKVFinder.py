# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pyKVFinder
else:
    import _pyKVFinder

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def igrid(grid, size):
    return _pyKVFinder.igrid(grid, size)

def fgrid(grid, size):
    return _pyKVFinder.fgrid(grid, size)

def dgrid(grid, size):
    return _pyKVFinder.dgrid(grid, size)

def cgrid(grid, size):
    return _pyKVFinder.cgrid(grid, size)

def fill(grid, atoms, reference, sincos, step, probe, nthreads):
    return _pyKVFinder.fill(grid, atoms, reference, sincos, step, probe, nthreads)

def _fill_receptor(receptor, nx, ny, nz, atoms, reference, sincos, step, probe_in, is_ses, nthreads, verbose):
    return _pyKVFinder._fill_receptor(receptor, nx, ny, nz, atoms, reference, sincos, step, probe_in, is_ses, nthreads, verbose)

def _fill_cavity(cavities, atoms, reference, sincos, step, nthreads):
    return _pyKVFinder._fill_cavity(cavities, atoms, reference, sincos, step, nthreads)

def check_protein_neighbours(grid, i, j, k):
    return _pyKVFinder.check_protein_neighbours(grid, i, j, k)

def ses(grid, step, probe, nthreads):
    return _pyKVFinder.ses(grid, step, probe, nthreads)

def subtract(PI, PO, nx, ny, nz, step, removal_distance, nthreads):
    return _pyKVFinder.subtract(PI, PO, nx, ny, nz, step, removal_distance, nthreads)

def filter_noise(grid, nthreads):
    return _pyKVFinder.filter_noise(grid, nthreads)

def adjust(grid, ligand, reference, sincos, step, ligand_cutoff, nthreads):
    return _pyKVFinder.adjust(grid, ligand, reference, sincos, step, ligand_cutoff, nthreads)

def _filter_pdb(nx, ny, nz, atoms, reference, sincos, step, probe, nthreads):
    return _pyKVFinder._filter_pdb(nx, ny, nz, atoms, reference, sincos, step, probe, nthreads)

def filter(grid, P1, ndims, P2, sincos, step, probe_out, nthreads):
    return _pyKVFinder.filter(grid, P1, ndims, P2, sincos, step, probe_out, nthreads)

def check_unclustered_neighbours(grid, i, j, k):
    return _pyKVFinder.check_unclustered_neighbours(grid, i, j, k)

def DFS(grid, i, j, k, tag):
    return _pyKVFinder.DFS(grid, i, j, k, tag)

def remove_cavity(grid, tag, nthreads):
    return _pyKVFinder.remove_cavity(grid, tag, nthreads)

def _cluster(grid, step, volume_cutoff, nthreads):
    return _pyKVFinder._cluster(grid, step, volume_cutoff, nthreads)

def _detect(PI, nx, ny, nz, atoms, reference, sincos, step, probe_in, probe_out, removal_distance, volume_cutoff, box_adjustment, P2, is_ses, nthreads, verbose):
    return _pyKVFinder._detect(PI, nx, ny, nz, atoms, reference, sincos, step, probe_in, probe_out, removal_distance, volume_cutoff, box_adjustment, P2, is_ses, nthreads, verbose)

def _detect_ladj(PI, nx, ny, nz, atoms, ligand, reference, sincos, step, probe_in, probe_out, removal_distance, volume_cutoff, ligand_adjustment, ligand_cutoff, box_adjustment, P2, is_ses, nthreads, verbose):
    return _pyKVFinder._detect_ladj(PI, nx, ny, nz, atoms, ligand, reference, sincos, step, probe_in, probe_out, removal_distance, volume_cutoff, ligand_adjustment, ligand_cutoff, box_adjustment, P2, is_ses, nthreads, verbose)

def define_surface_points(cavities, i, j, k):
    return _pyKVFinder.define_surface_points(cavities, i, j, k)

def filter_surface(cavities, surface, nx, ny, nz, nthreads):
    return _pyKVFinder.filter_surface(cavities, surface, nx, ny, nz, nthreads)

def check_voxel_class(surface, nx, ny, nz, i, j, k):
    return _pyKVFinder.check_voxel_class(surface, nx, ny, nz, i, j, k)

def _area(surface, step, areas, nthreads):
    return _pyKVFinder._area(surface, step, areas, nthreads)

def _volume(cavities, step, volumes, nthreads):
    return _pyKVFinder._volume(cavities, step, volumes, nthreads)

def _spatial(cavities, surface, volumes, areas, step, nthreads, verbose):
    return _pyKVFinder._spatial(cavities, surface, volumes, areas, step, nthreads, verbose)
class pts(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    X1 = property(_pyKVFinder.pts_X1_get, _pyKVFinder.pts_X1_set)
    X2 = property(_pyKVFinder.pts_X2_get, _pyKVFinder.pts_X2_set)
    Y1 = property(_pyKVFinder.pts_Y1_get, _pyKVFinder.pts_Y1_set)
    Y2 = property(_pyKVFinder.pts_Y2_get, _pyKVFinder.pts_Y2_set)
    Z1 = property(_pyKVFinder.pts_Z1_get, _pyKVFinder.pts_Z1_set)
    Z2 = property(_pyKVFinder.pts_Z2_get, _pyKVFinder.pts_Z2_set)

    def __init__(self):
        _pyKVFinder.pts_swiginit(self, _pyKVFinder.new_pts())
    __swig_destroy__ = _pyKVFinder.delete_pts

# Register pts in _pyKVFinder:
_pyKVFinder.pts_swigregister(pts)


def define_boundary_points(cavities, i, j, k):
    return _pyKVFinder.define_boundary_points(cavities, i, j, k)

def filter_boundary(cavities, cavs, boundarys, nthreads):
    return _pyKVFinder.filter_boundary(cavities, cavs, boundarys, nthreads)

def remove_boundary(cavities, ncav, boundaries, nthreads):
    return _pyKVFinder.remove_boundary(cavities, ncav, boundaries, nthreads)

def estimate_depth(cavities, depths, nx, ny, nz, max_depth, avg_depth, n, cavs, boundaries, step, nthreads):
    return _pyKVFinder.estimate_depth(cavities, depths, nx, ny, nz, max_depth, avg_depth, n, cavs, boundaries, step, nthreads)

def _depth(cavities, depths, max_depth, avg_depth, step, nthreads, verbose):
    return _pyKVFinder._depth(cavities, depths, max_depth, avg_depth, step, nthreads, verbose)

def _openings2cavities(o2c, cavities, openings, nthreads):
    return _pyKVFinder._openings2cavities(o2c, cavities, openings, nthreads)

def remove_enclosed_cavity(openings, cavities, depths, ncav, nthreads):
    return _pyKVFinder.remove_enclosed_cavity(openings, cavities, depths, ncav, nthreads)

def filter_openings(openings, depths, nx, ny, nz, nthreads):
    return _pyKVFinder.filter_openings(openings, depths, nx, ny, nz, nthreads)

def _openings(openings, cavities, depths, ncav, openings_cutoff, step, nthreads, verbose):
    return _pyKVFinder._openings(openings, cavities, depths, ncav, openings_cutoff, step, nthreads, verbose)
class res(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pos = property(_pyKVFinder.res_pos_get, _pyKVFinder.res_pos_set)
    next = property(_pyKVFinder.res_next_get, _pyKVFinder.res_next_set)

    def __init__(self):
        _pyKVFinder.res_swiginit(self, _pyKVFinder.new_res())
    __swig_destroy__ = _pyKVFinder.delete_res

# Register res in _pyKVFinder:
_pyKVFinder.res_swigregister(res)


def create(pos):
    return _pyKVFinder.create(pos)

def insert(head, new):
    return _pyKVFinder.insert(head, new)

def interface(cavities, pdb, atoms, reference, sincos, step, probe_in, ncav, nthreads):
    return _pyKVFinder.interface(cavities, pdb, atoms, reference, sincos, step, probe_in, ncav, nthreads)

def _constitutional(cavities, pdb, atoms, reference, sincos, step, probe_in, ncav, nthreads, verbose):
    return _pyKVFinder._constitutional(cavities, pdb, atoms, reference, sincos, step, probe_in, ncav, nthreads, verbose)

def get_hydrophobicity_value(resname, resn, scales):
    return _pyKVFinder.get_hydrophobicity_value(resname, resn, scales)

def project_hydropathy(hydropathy, surface, atoms, reference, sincos, resname, resn, scales, step, probe_in, nthreads):
    return _pyKVFinder.project_hydropathy(hydropathy, surface, atoms, reference, sincos, resname, resn, scales, step, probe_in, nthreads)

def estimate_average_hydropathy(avgh, hydropathy, surface, nx, ny, nz, nthreads):
    return _pyKVFinder.estimate_average_hydropathy(avgh, hydropathy, surface, nx, ny, nz, nthreads)

def _hydropathy(hydropathy, avgh, surface, atoms, reference, sincos, resname, resn, scales, step, probe_in, nthreads, verbose):
    return _pyKVFinder._hydropathy(hydropathy, avgh, surface, atoms, reference, sincos, resname, resn, scales, step, probe_in, nthreads, verbose)

def _export(fn, cavities, surface, B, Q, reference, sincos, step, ncav, nthreads, append, model):
    return _pyKVFinder._export(fn, cavities, surface, B, Q, reference, sincos, step, ncav, nthreads, append, model)

def _export_openings(fn, openings, reference, sincos, step, nopenings, nthreads, append, model):
    return _pyKVFinder._export_openings(fn, openings, reference, sincos, step, nopenings, nthreads, append, model)


